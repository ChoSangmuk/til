# 04장: 변수

## 4.1 변수란 무엇인가? 왜 필요한가?
먼저 사람이 [예제 04-01](../PracticeSource/Chapter4/04-01.js)를 계산하려면 10, 20, + 라는 기호의 의미와 10 + 20이라는 식의 의미를 해석할 수 있어야 한다. 식의 연산(+, 더하기)은 두뇌에서 진행되며, 사용된 피연산자(10, 20)와 연산의 결과(30) 또한 두뇌에 기억된다.

컴퓨터 역시 사람과 유사하게 동작한다. 자바스크립트 엔진(이하 JS 엔진)은 10, 20, + 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 식(표현식)의 의미도 해석(파싱)할 수 있어야 한다. 사람의 경우 모든 기억 및 연산이 두뇌에서 이루어지지만, **컴퓨터는 CPU를 통해 연산하고, 메모리(Memory)를 통해 데이터를 기억**한다.

<br>

**메모리는 데이터를 저장할 수 있는 메모리 셀(Memory Cell)의 집합체**를 의미한다. 메모리 셀 하나의 크기는 1Byte(8Bit)이며, 컴퓨터는 메모리 셀의 크기, 즉 1Byte 단위로 데이터를 저장하거나 읽어 들인다. 각 **셀은 주소가 존재하여 메모리 공간 상의 실제 위치**를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현(16진수)된다. 예를 들어 4GB 메모리는 0x00000000 ~ 0xFFFFFFFF까지의 메모리 주소를 갖는다.

<img src="../Image/Chapter4/memory-address.jpeg" width="200" height="100%"><br> - 이미지 출처 : https://blog.daum.net/coolprogramming/8

<br>

CPU 연산이 성공적으로 종료되면 그 결과도 메모리에 저장되게 되는데, 결과가 저장된 **메모리의 주소를 기억하지 않으면 메모리에 저장된 값을 재사용할 수 없는 문제**가 발생한다.

개발자가 메모리 주소로 직접 제어하는 방법이 가장 효율적이라고 생각할 수 있지만, 운영체제가 사용 중인 메모리에 접근하여 값을 제어하면 시스템 전체에 심각한 오류를 발생시키며, 동일한 코드의 실행이어도 값이 저장될 메모리의 주소는 메모리 상황에 따라 결정됨으로 사실상 불가능하다. 따라서 **JS 엔진은 개발자의 직접적인 메모리 제어를 허용하지 않는다. 그렇다면 어떻게 메모리 주소를 기억해서 사용할 수 있을까?**

<br>

프로그래밍 언어는 메모리에 대한 제어를 위해 **변수**라는 메커니즘을 제공한다. **변수(variable)는 값(메모리 공간)의 위치를 가르키는 상징적인 이름**을 의미하며, 프로그래밍 언어 번역기(컴파일러, 인터프리터)에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 이러한 방식을 통해 개발자는 안전하게 값을 제어할 수 있다.
> 하나의 변수에 여러 개의 값을 저장하고 싶은 경우, 배열 혹은 객체와 같은 자료구조를 이용한다. ([예제 04-02](../PracticeSource/Chapter4/04-02.js) 참고)

<br>

[예제 04-03](../PracticeSource/Chapter4/04-03.js)에서 JS 엔진은 연산(10 + 20)을 수행하고 그 결과(30)를 메모리 공간에 저장한다. 이때 저장된 결과(30)를 다시 읽어들여 재사용할 수 있도록 해당 메모리 공간(주소)에 상징적인 이름을 붙인 것이 바로 변수다.

고유한 이름을 **변수 명**(또는 변수 이름), 변수에 저장된 값을 **변수 값**, 변수에 값을 저장하는 것은 **할당(대입, 저장)**, 변수에 저장된 값을 읽어들이는 것을 **참조**라고 한다. **변수 명으로 참조를 요청하면 JS 엔진은 변수 명과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환**한다. 변수에 저장된 값의 의미를 파악할 수 있는 변수 명은 가독성을 높이는 부수적인 효과가 있다.

<br>

## 4.2 식별자
변수 명, 변수 이름을 식별자(Identifier)라고도 한다. 식별자는 메모리의 주소를 기억해야할 필요가 있는데, 이 정보 역시 메모리에 저장되어야 한다.

식별자라는 용어는 변수 이름에만 국한되어 사용되는 것이 아니며 함수, 클래스 등의 이름은 모두 식별자이다. 변수 이름으로는 메모리 상에 존재하는 변수 값을 식별할 수 있고, 함수 이름으로는 메모리 상에 존재하는 함수(자바스크립트에서는 함수도 값)를 식별할 수 있다. 즉, **식별자는 메모리 주소에 붙인 이름**이라고 볼 수 있다.

식별자는 [4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)을 준수해야 하며, 선언(Declaration)을 통해 식별자의 존재를 JS 엔진에 알린다. 한번 더 명심해야 할 것은 **식별자가 값 자체를 기억하는 것이 아니라 메모리 주소를 기억한다는 점**이다.

<br>

## 4.3 변수 선언
**변수 선언(Variable Declaration)이란** 변수를 생성하는 것으로, **1. 메모리 공간을 확보(Allocate)하고 2.변수 이름(식별자)과 확보된 메모리 공간의 주소를 연결(Name Binding)** 해서 값을 저장할 수 있게 준비하는 것이다. 선언으로 보장받은 메모리 공간은 해제(Release)되기 전엔 보호되므로 안전하게 사용할 수 있다.

변수를 사용하려면 반드시 선언이 필요하며, 이때 **ES6 이전부터 JS 엔진이 제공해왔던 var**를 사용하거나 ES6 이후 추가된 **let, const 키워드(Keyword)를 사용**한다. 

- **ES5 vs. ES6**
> var의 단점과 문제점([15.1 var 키워드로 선언한 변수의 문제점](Chapter15.md/#151-var-키워드로-선언한-변수의-문제점)), 스코프와 같은 자바스크립트의 핵심 개념을 정확히 파악해야 const와 let가 추가된 이유를 명확히 이해할 수 있다.<br>
> const와 let 키워드가 추가된 이후, var 키워드가 폐기(Deprecated)된 것은 아니다. ES6는 기본적으로 하위 호환성을 유지하면서 ES5의 기반 위에 새로운 기능을 추가한 것임으로 ES5의 문법을 그대로 사용할 수 있다.

var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언하는 것을 지시하는 키워드다. [예제 04-04](../PracticeSource/Chapter4/04-04.js)에서는 score라는 변수 선언을 하였다. 변수 선언 후에 JS 엔진에 의해 변수(score)가 가르키는 메모리 공간에는 undefined라는 값이 암묵적으로 할당되어 초기화 된다.

- **키워드(Keyword)**
> 키워드는 자바스크립트 코드를 해석하고 실행하는 JS 엔진이 수행할 동작을 규정해 놓은 일종의 명령어다. JS 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다.

- **undefined**
> undefined는 자바스크립트에서 제공하는 원시 타입의 값(Primitive Value)이다. [06장: 데이터 타입](Chapter6.md)에서 자세히 살펴볼 예정이다.

예제 04-04로 짐작할 수 있듯이 JS 엔진의 변수 선언은 다음과 같은 두 단계 과정을 거쳐 수행한다.
1. 선언단계 : 변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. 일반적으로 초기화는 변수가 선언 된 이후 최초로 겂을 할당하는 것을 의미하지만, var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 따라서 var 키워드로 선언한 변수값은 어떠한 값을 할당하지 않아도 undefined 라는 값을 가진다.

자바스크립트는 이러한 암묵적 초기화를 통해 메모리에 남아있을 수 있는 쓰레기 값(Garbage Value)의 위협으로부터 안전하다.

변수 뿐만 아니라 모든 식별자(함수, 클래스 등)는 같은 과정을 거친다. 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다. JS 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러다.

- **변수 이름은 어디에 등록되는가?**
> **실행 컨텍스트(Execution Context)** 는 JS 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. JS 엔진은 변수 이름을 비롯한 식별자, 스코프를 실행 컨텍스트내에서 key/value 형식인 객체로 등록, 관리한다.<br>
> JS 엔진이 변수를 관리하는 메커니즘은 [13장: 스코프](Chapter13.md)와 [23장: 실행 컨텍스트](Chapter23.md)에서 자세히 살펴볼 예정이다.

<br>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅
## 4.5 값의 할당
## 4.6 값의 재할당
## 4.7 식별자 네이밍 규칙
## Summary

<br>

## Reference
- [모던 자바스크립트 Deep Dive 공식 예제코드 저장소](https://github.com/wikibook/mjs) 

<br>

-----
### [< 이전](Chapter3.md) | [목차](../README.md) | [다음 >](Chapter5.md)