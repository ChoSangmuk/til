# 04장: 변수

## 4.1 변수란 무엇인가? 왜 필요한가?
먼저 사람이 [예제 04-01](../PracticeSource/Chapter4/04-01.js)를 계산하려면 10, 20, + 라는 기호의 의미와 10 + 20이라는 식의 의미를 해석할 수 있어야 한다. 식의 연산(+, 더하기)은 두뇌에서 진행되며, 사용된 피연산자(10, 20)와 연산의 결과(30) 또한 두뇌에 기억된다. 컴퓨터 역시 사람과 유사하게 동작한다. 자바스크립트 엔진(이하 JS 엔진)은 10, 20, + 기호(리터럴과 연산자)의 의미를 알고 있어야 하며, 식(표현식)의 의미도 해석(파싱)할 수 있어야 한다. 사람의 경우 모든 기억 및 연산이 두뇌에서 이루어지지만, **컴퓨터는 CPU를 통해 연산하고, 메모리(Memory)를 통해 데이터를 기억**한다.

<br>

**메모리는 데이터를 저장할 수 있는 메모리 셀(Memory Cell)의 집합체**를 의미한다. 메모리 셀 하나의 크기는 1Byte(8Bit)이며, 컴퓨터는 메모리 셀의 크기, 즉 1Byte 단위로 데이터를 저장하거나 읽어 들인다. 각 **셀은 주소가 존재하여 메모리 공간 상의 실제 위치**를 나타내며, 0부터 시작해서 메모리의 크기만큼 정수로 표현(16진수)된다. 예를 들어 4GB 메모리는 0x00000000 ~ 0xFFFFFFFF까지의 메모리 주소를 갖는다.

<img src="../Image/Chapter4/memory-address.jpeg" width="200" height="100%"><br> - 이미지 출처 : https://blog.daum.net/coolprogramming/8

<br>

CPU 연산이 성공적으로 종료되면 그 결과도 메모리에 저장되게 되는데, 결과가 저장된 **메모리의 주소를 기억하지 않으면 메모리에 저장된 값을 재사용할 수 없는 문제**가 발생한다. 개발자가 메모리 주소로 직접 제어하는 방법이 가장 효율적이라고 생각할 수 있지만, 운영체제가 사용 중인 메모리에 접근하여 값을 제어하면 시스템 전체에 심각한 오류를 발생시키며, 동일한 코드의 실행이어도 값이 저장될 메모리의 주소는 메모리 상황에 따라 결정됨으로 사실상 불가능하다. 따라서 **JS 엔진은 개발자의 직접적인 메모리 제어를 허용하지 않는다. 그렇다면 어떻게 메모리 주소를 기억해서 사용할 수 있을까?**

<br>

프로그래밍 언어는 메모리에 대한 제어를 위해 **변수**라는 메커니즘을 제공한다. **변수(variable)는 값(메모리 공간)의 위치를 가르키는 상징적인 이름**을 의미하며, 프로그래밍 언어 번역기(컴파일러, 인터프리터)에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 이러한 방식을 통해 개발자는 안전하게 값을 제어할 수 있다.
> 하나의 변수에 여러 개의 값을 저장하고 싶은 경우, 배열 혹은 객체와 같은 자료구조를 이용한다. ([예제 04-02](../PracticeSource/Chapter4/04-02.js) 참고)

<br>

[예제 04-03](../PracticeSource/Chapter4/04-03.js)에서 JS 엔진은 연산(10 + 20)을 수행하고 그 결과(30)를 메모리 공간에 저장한다. 이때 저장된 결과(30)를 다시 읽어들여 재사용할 수 있도록 해당 메모리 공간(주소)에 상징적인 이름을 붙인 것이 바로 변수다. 고유한 이름을 **변수 명**(또는 변수 이름), 변수에 저장된 값을 **변수 값**, 변수에 값을 저장하는 것은 **할당(대입, 저장)**, 변수에 저장된 값을 읽어들이는 것을 **참조**라고 한다. **변수 명으로 참조를 요청하면 JS 엔진은 변수 명과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환**한다. 변수에 저장된 값의 의미를 파악할 수 있는 변수 명은 가독성을 높이는 부수적인 효과가 있다.

<br>

## 4.2 식별자
변수 명, 변수 이름을 식별자(Identifier)라고도 한다. 식별자는 메모리의 주소를 기억해야할 필요가 있는데, 이 정보 역시 메모리에 저장되어야 한다.<br>
식별자라는 용어는 변수 이름에만 국한되어 사용되는 것이 아니며 함수, 클래스 등의 이름은 모두 식별자이다. 변수 이름으로는 메모리 상에 존재하는 변수 값을 식별할 수 있고, 함수 이름으로는 메모리 상에 존재하는 함수(자바스크립트에서는 함수도 값)를 식별할 수 있다. 즉, **식별자는 메모리 주소에 붙인 이름**이라고 볼 수 있다.

식별자는 [4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)을 준수해야 하며, 선언(Declaration)을 통해 식별자의 존재를 JS 엔진에 알린다. 한번 더 명심해야 할 것은 **식별자가 값 자체를 기억하는 것이 아니라 메모리 주소를 기억한다는 점**이다.

<br>

## 4.3 변수 선언
**변수 선언(Variable Declaration)이란** 변수를 생성하는 것으로, **1. 메모리 공간을 확보(Allocate)하고 2.변수 이름(식별자)과 확보된 메모리 공간의 주소를 연결(Name Binding)** 해서 값을 저장할 수 있게 준비하는 것이다. 선언으로 보장받은 메모리 공간은 해제(Release)되기 전엔 보호되므로 안전하게 사용할 수 있다. 변수를 사용하려면 반드시 선언이 필요하며, 이때 **ES6 이전부터 JS 엔진이 제공해왔던 var**를 사용하거나 ES6 이후 추가된 **let, const 키워드(Keyword)를 사용**한다. 

- **ES5 vs. ES6**
> var의 단점과 문제점([15장: let, const 키워드와 블록 레벨 스코프](Chapter15.md)), 스코프와 같은 자바스크립트의 핵심 개념을 정확히 파악해야 ES6에서 const와 let가 추가된 이유를 명확히 이해할 수 있다.<br>
> ES6 이후 var 키워드가 폐기(Deprecated)된 것은 아니다. ES6는 기본적으로 ES5와 하위 호환성을 유지하면서 새로운 기능을 추가한 것임으로 ES5의 문법을 그대로 사용할 수 있다.

- **키워드(Keyword)**
> 키워드란 JS 엔진이 수행할 동작을 규정해 놓은 일종의 명령어 혹은 예약어다. JS 엔진은 키워드를 만나면 자신이 수행하기로 약속한 동작을 수행한다.<br>
> ex) var - 뒤에 오는 변수 이름으로 새로운 변수를 선언하는 것을 지시하는 키워드

<br>

JS 엔진의 변수 선언은 다음과 같은 두 단계 과정을 거쳐 수행한다.

1. 선언 단계 : 변수 이름을 어딘가(?)에 등록해서 JS 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보(Allocate)하고 암묵적으로 undefined를 할당해 초기화한다.

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다. 일반적으로 초기화는 변수가 선언 된 이후 최초로 겂을 할당하는 것을 의미하지만, var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행된다. 따라서 var 키워드로 선언한 변수 값은 어떠한 값을 할당하지 않아도 undefined 값을 가진다. ([예제 04-04](../PracticeSource/Chapter4/04-04.js) 참고)

- **undefined**
> undefined는 자바스크립트에서 제공하는 원시 타입의 값(Primitive Value)이다. [06장: 데이터 타입](Chapter6.md)에서 자세히 살펴볼 예정이다.

- **변수 이름은 어디에 등록되는가?**
> **실행 컨텍스트(Execution Context)** 는 JS 엔진이 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역이다. JS엔진은 실행 컨텍스트를 통해 식별자, 스코프를 관리하며, 변수의 이름/값을 Key/Value 형식의 객체로 등록, 관리된다.<br>
> JS 엔진이 변수를 관리하는 메커니즘은 [13장: 스코프](Chapter13.md)와 [23장: 실행 컨텍스트](Chapter23.md)에서 자세히 살펴볼 예정이다.

<br>

자바스크립트에서 변수를 포함한 모든 식별자(함수, 클래스 등)는 같은 과정을 거치게 되며, 이러한 암묵적 초기화를 통해 메모리에 남아있을 수 있는 쓰레기 값(Garbage Value)의 위협으로부터 안전하다.

<br>

## 4.4 변수 선언의 실행 시점과 변수 호이스팅
[예제 04-05](../PracticeSource/Chapter4/04-05.js)에서는 변수 선언보다 변수 참조, 출력하는 코드가 먼저 있다. JS 엔진에 의해 예제가 한 줄씩 순차적으로 실행될 때 해당 변수(score)가 선언되어 있지 않음으로 참조오류(ReferenceError)가 발생할 것처럼 보이지만 실제로는 undefined가 출력된다. 이는 자바스크립트에서 **변수의 선언이 코드가 실행되는 시점(Runtime)이 아니라 그 이전 단계에서 먼저 실행**되기 때문이다.

JS 엔진은 코드를 실행하기 앞서 코드의 평가 과정([23장: 실행 컨텍스트](Chapter23.md))을 진행하는데, 이 때 변수 선언을 포함한 모든 선언문을 찾아 먼저 실행한다. 이러한 평가 과정이 끝나면 비로소 선언을 제외한 코드가 한 줄씩 순차적으로 실행된다. 즉, JS 엔진은 **선언문이 코드 어디에 있든 상관없이 다른 코드보다 먼저 실행**하는데, 이러한 **자바스크립트 공유의 특징을 호이스팅(Hoisting)** 이라고 한다. 변수 선언뿐만 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. 

<br>

## 4.5 값의 할당
변수에 값을 할당(Assignment, 대입, 저장)할 때는 할당 연산자 '=' 를 사용하며, 우변의 값을 좌변의 변수에 할당한다. 변수 선언과 변수의 할당은 하나의 문(Statement)으로 단축하여 표현할 수 있지만, JS 엔진은 변수 선언과 값의 할당을 하나의 문으로 표현해도 2개의 문으로 나누어 각각 실행한다. ([예제 04-06](../PracticeSource/Chapter4/04-06.js), [예제 04-07](../PracticeSource/Chapter4/04-07.js) 참고)

이때 염두할 점은 변수의 선언과 값의 할당 시점이 다르다는 것이다. 변수 선언은 평가 과정에서 실행되지만, 값의 할당은 Runtime에 실행된다. [예제 04-08](../PracticeSource/Chapter4/04-08.js)에서 ① 변수 선언은 Runtime 이전에 실행되고, ② 값의 할당은 Runtime에 실행된다. 따라서 ② 값의 할당하는 시점에 변수의 선언은 완료된 상태이며 이미 undefined로 암묵적 초기화 되어있다. [예제 04-09](../PracticeSource/Chapter4/04-09.js) 역시 동일하게 작동한다.

<br>

한 가지 더 주의할 점은 **변수의 값을 할당할 때는 이전 값 undefined가 저장되어있던 기존의 메모리 공간을 지우고 그 메모리 공간에 새로운 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 곳에 새로운 값을 저장한다**는 것이다.
이러한 사실을 바타으로 [예제 04-10](../PracticeSource/Chapter4/04-10.js)의 실행 과정을 추측해보고, 컴퓨터를 통해 결과를 확인해보자

<br>

## 4.6 값의 재할당
**재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또 다시 할당하는 것**을 말한다. ([예제 04-11](../PracticeSource/Chapter4/04-11.js) 참고)<br>
만약, 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(Constant)라 한다. 

- **const 키워드**
> ES6에 도입된 const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 즉, const 키워드는 단 한번만 할당할 수 있는 변수를 선언할 수 있으며, 상수이외에 용도로 사용도 가능하다. 이는 [15장: let, const 키워드와 블록 레벨 스코프](Chapter15.md)에서 자세히 살펴볼 예정이다. 

<br>

앞서 잠시 언급했듯이 **변수에 값이 재할당 되는 경우, 기존 메모리 공간을 재사용하는 것이 아니라 새로운 메모리 공간을 확보**한다. 이때 식별자와 연결되지 않은 메모리 공간이 존재하게 되는데, 이 값은 더 이상 필요하지 않다는 것을 의미한다. 이러한 불필요한 값은 가비지 컬렉터(Garbage Collector, 이하 GC)에 의해 메모리에서 자동 해제되는데, 언제 해제될지는 예측할 수 없다.

- **가비지 컬렉터(Garbage Collector, GC)**
> 가비지 컬렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다. 더 이상 사용되지 않는 메모리란 어떤 식별자도 참조하지 않는 메모리 공간을 의미한다. 자바스크립트는 GC를 내장하고 있는 매니지드 언어로, GC를 통해 메모리 누수(Memory Leak)를 방지한다.

- **언매니지드 언어(Unmanaged) vs. 매니지드 언어(Managed)**
> 프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드(Unmanaged) 언어와 매니지드(Managed) 언어로 분류할 수 있다.
> |언매니지드(Unmanaged) 언어|매니지드(Managed) 언어|
> |-----|-----|
> |C 언어 ... | Java, JavaScript ... |
> |개발자가 명시적으로 메모리를 할당, 해제|언어 차원에서 메모리를 할당, 해제|
> |malloc(), free() 같은 저 수준의 메모리 제어 기능을 제공|개발자의 직접적인 메모리 제어를 허용하지 않음<br>미 사용 메모리의 해제는 GC에 의해 수행|
> |개발자의 역량에 따라 최적의 성능을 확보<br>but. 반대의 경우 치명적인 오류 발생|개발자의 역량에 의존하는 부분을 상대적으로 작음<br>일정한 생산성을 확보<br>but. 성능 면에서 손실을 감수 할 수 밖에 없음|

<br>

## 4.7 식별자 네이밍 규칙
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 다음의 규칙을 준수해야한다.

1. 식별자는 특수 문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
2. 단, 식별자는 특수 문자를 제외한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
3. 예약어는 식별자로 사용할 수 없다.

- **예액어(Reserved Word)**
> 예약어는 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어를 말한다. 
> |||||||
> |-----|-----|-----|-----|-----|-----| 
> |await|break|case|catch|class|const|
> |continue|debugger|default|delete|do|else|
> |enum|export|extends|false|finally|for|
> |function|if|implements*|import|in|instanceof|
> |interface*|let*|new|null|package*|private*|
> |protected*|public*|return|super|static*|switch|
> |this|throw|true|try|typeof|var|
> |void|while|with|yield*|||
> 
> *식별자로 사용 가능하나 strict mode에서 사용 불가

<br>

변수 이름도 식별자이므로 네이밍 규칙을 따라야한다. 

- [에제 04-12](../PracticeSource/Chapter4/04-12.js) 변수 이름의 예시이다. 변수 선언을 쉼표(,)로 구분하여 동시에 여러 개를 할 수 있지만 가독성이 나빠짐으로 권장하지 않는다.
- [예제 04-13](../PracticeSource/Chapter4/04-13.js) ES5부터 식별자를 만들 때 유니코드 문자를 허용함으로 알파벳 이외 한글이나 일본어 식별자도 사용할 수 있지만 권장하지는 않는다.
- [예제 04-14](../PracticeSource/Chapter4/04-14.js) 명명 규칙에 위배되는 변수 이름임으로 사용할 수 없다.
- [예제 04-15](../PracticeSource/Chapter4/04-15.js) 자바스크립트는 대소문자를 구별하므로 예제의 변수들은 각각 별개의 변수다.
- [예제 04-16](../PracticeSource/Chapter4/04-16.js) 변수 이름은 변수의 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야한다. 좋은 변수 이름은 코드의 가독성을 높인다.
- [예제 04-17](../PracticeSource/Chapter4/04-17.js) 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.
- [예제 04-18](../PracticeSource/Chapter4/04-18.js) 네이밍 컨벤션(Naming Convention)은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다. 주로 4가지 네이밍 컨벤션이 사용된다. 자바스크립트에서는 일반적으로 변수, 함수 명은 카멜 케이스를 사용하고, 객체, 생성자 함수, 클래스 명은 파스칼 케이스를 사용하는 것이 유리하다.(ECMAScript 기준)

<br>

## Summary
- 컴퓨터는 CPU를 통해 연산하고, 메모리(Memory)를 통해 데이터를 기억한다. 메모리는 데이터를 저장할 수 있는 메모리 셀(Memory Cell)의 집합체이며 각각의 셀은 주소를 가진다.
- 메모리의 주소를 기억하지 않으면 메모리에 저장된 값을 재사용할 수 없는 문제가 있지만, JS 엔진은 개발자의 직접적인 메모리 제어를 허용하지 않는다. 대신 **변수(variable)라는 값(메모리 공간)의 위치를 가르키는 상징적인 이름**을 통해 메모리 상의 값을 제어할 수 있다. 변수 명으로 참조를 요청하면 JS 엔진은 변수 명과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.
- 변수 이름, 변수 명을 식별자라고 하며, 메모리 주소에 붙인 이름이다. 따라서, 식별자는 값 자체를 기억하는 것이 아니라 메모리 주소를 기억한다.
- 변수를 사용하기 위해서는 선언이 먼저 이루어 져야하며, 이때 약속된 키워드(var, let, const)를 사용한다. 변수의 선언은 2단계 **1. 변수 이름을 어딘가(?)에 등록해서 JS 엔진에 변수의 존재를 알린다. 2. 값을 저장하기 위한 메모리 공간을 확보(Allocate)하고 암묵적으로 undefined를 할당해 초기화한다.** 를 거친다. 이를 통해 메모리에 남아있을 수 있는 쓰레기 값(Garbage Value)의 위협으로부터 안전하다.
- 변수의 선언은 실행 단계 이전의 평가 단계에서 진행되며, 평가 단계가 종료되어야 비로소 실행 단계로 넘어간다. 이로 인해 **선언문이 코드 어디에 있든 상관없이 다른 코드보다 먼저 실행**하는데, 이러한 **자바스크립트 공유의 특징을 호이스팅(Hoisting)** 이라고 한다.
- **변수의 값이 할당되는 경우, 새로운 메모리 공간을 확보하고 해당 메모리에 값을 할당**한다. 메모리 공간을 가르키는 식별자가 없는 경우, 해당 주소의 값은 무의미한 것으로 판단되어 GC에 의해 처리된다.
- 자바스크립트의 식별자는 네이밍 규칙을 준수해야하며, 네이밍 컨벤션(Naming Convention)의 변수, 함수 명은 카멜 케이스를 사용하고, 객체, 생성자 함수, 클래스 이름은 파스칼 케이스를 사용하는 것이 유리하다.

<br>

## Reference
- [모던 자바스크립트 Deep Dive 공식 예제코드 저장소](https://github.com/wikibook/mjs) 

<br>

-----
### [< 이전](Chapter3.md) | [목차](../README.md) | [다음 >](Chapter5.md)